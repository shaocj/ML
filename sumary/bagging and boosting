1、	blending 和 bagging
所有的g是已知的，即blending。另外一种情况是所有g未知，只能通过手上的资料重构g，即learning。
aggregation将不同H结合起来得到更好的预测模型，起到了特征转换的效果；
对各种效果较好的可能性进行组合，所以，aggregation也起到了正则化（regularization）的效果，让预测模型更具有代表性；
得到了aggregation的两个优势：feature transform和regularization，通常feature transform和regularization是对立的，如果进行feature transform，那么regularization的效果通常很差，反之亦然。也就是说，单一模型通常只能倾向于feature transform和regularization之一，在两者之间做个权衡，aggregation却能将feature transform和regularization各自的优势结合起来。
那对于我们已经选择的性能较好的一些矩gtgt，如何将它们进行整合、合并，来得到最佳的预测模型呢？这个过程称为blending。
不同gtgt的平均误差共识，用偏差bias表示；不同gtgt与共识的差距是多少，反映gtgt之间的偏差，用方差variance表示；uniform blending的操作时求平均的过程，这样就削减弱化了上式第一项variance的值，从而演算法的表现就更好了，能得到更加稳定的表现。
linear blending，每个gtgt赋予的权重αtαt并不相同，其中αt≥0αt≥0。我们最终得到的预测结果等于所有gtgt的线性组合。如何确定αtαt的值，方法是利用误差最小化的思想，找出最佳的αtαt，使Ein(α)Ein(α)取最小值。
blending的优点是模型复杂度提高，更容易获得更好的预测模型；缺点是复杂模型也容易带来过拟合的危险。
如何利用已有的一份数据集来构造出不同的gtgt呢？bias-variance，即一个演算法的平均表现可以被拆成两项，一个是所有gtgt的共识（bias），一个是不同gtgt之间的差距是多少（variance）。其中每个gtgt都是需要新的数据集的。只有一份数据集的情况下，如何构造新的数据集？做法就是bootstrapping。bootstrapping的做法是，假设有N笔资料，先从中选出一个样本，再放回去，再选择一个样本，再放回去，共重复N次。这样我们就得到了一个新的N笔资料，这个新的Dt˘Dt˘中可能包含原D里的重复样本点，也可能没有原D里的某些样本，Dt˘Dt˘与D类似但又不完全相同。值得一提的是，抽取-放回的操作不一定非要是N，次数可以任意设定。例如原始样本有10000个，我们可以抽取-放回3000次，得到包含3000个样本的Dt˘Dt˘也是完全可以的。利用bootstrap进行aggragation的操作就被称为bagging。
2、	bagging和boosting
先介绍Bagging方法：
Bagging即套袋法，其算法过程如下：
1.	从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）
2.	每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树、感知器等）
3.	对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）
Boosting：
在分类问题中它通过改变训练样本的权重，学习多个分类器，并将分类器进行线性组合。
AdaBoosting方式每次使用的是全部的样本，每轮训练改变样本的权重。下一轮训练的目标是找到一个函数f 来拟合上一轮的残差。当残差足够小或者达到设置的最大迭代次数则停止。Boosting会减小在上一轮训练正确的样本的权重，增大错误样本的权重。（对的残差小，错的残差大）
梯度提升的Boosting方式是使用代价函数对上一轮训练出的模型函数f的偏导来拟合残差。
Bagging，Boosting二者之间的区别
Bagging和Boosting的区别：
1）样本选择上：
Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。
Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。
2）样例权重：
Bagging：使用均匀取样，每个样例的权重相等
Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。
3）预测函数权重：
Bagging：所有预测函数的权重相等。
Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。
4）是否可以并行计算：
Bagging：各个预测函数可以并行生成
Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。
5）为什么说bagging是减少variance，而boosting是减少bias？（重要）
https://www.cnblogs.com/earendil/p/8872001.html
https://www.zhihu.com/question/26760839

			Bagging和随机森林
			Bagging对样本重采样，对每一重采样得到的子样本集训练一个模型，最后取平均。由于子样本集的相似性以及使用的是同种模型，因此各模型有近似相等的bias和variance（事实上，各模型的分布也近似相同，但不独立）。由于 ，所以bagging后的bias和单个子模型的接近，一般来说不能显著降低bias。另一方面，若各子模型独立，则有 ，此时可以显著降低variance。若各子模型完全相同，则 
，此时不会降低variance。bagging方法得到的各子模型是有一定相关性的，属于上面两个极端状况的中间态，因此可以一定程度降低variance。为了进一步降低variance，Random forest通过随机选取变量子集做拟合的方式de-correlated了各子模型（树），使得variance进一步降低。（用公式可以一目了然：设有i.d.的n个随机变量，方差记为 ，两两变量之间的相关性为 ，则 的方差为 
，bagging降低的是第二项，random forest是同时降低两项。详见ESL p588公式15.1）。
		boosting从优化角度来看，是用forward-stagewise这种贪心法去最小化损失函数 。例如，常见的AdaBoost即等价于用这种方法最小化exponential loss： 。所谓forward-stagewise，就是在迭代的第n步，求解新的子模型f(x)及步长a（或者叫组合系数），来最小化 ，这里 是前n-1步得到的子模型的和。因此boosting是在sequential地最小化损失函数，其bias自然逐步下降。但由于是采取这种sequential、adaptive的策略，各子模型之间是强相关的，于是子模型之和并不能显著降低variance。所以说boosting主要还是靠降低bias来提升预测精度。
		通常来说boosting是在优化loss function，在降低loss，那么很显然，这在很大程度上是减少bias。而bagging，之所以进行bagging，是希望模型能够具有更好的鲁棒性，也就是稳定性，希望避免过拟合，显然这就是在减少variance。
	bagging的方法主要是随机取样，每个模型的目标函数跟单模型并没有很大的区别，所以bias变化不大，而多个模型的集成降低异常点的影响，这两个方法都可以降低variance
boosting的方法通过残差学习，最后得预测值发生了改变，是由多个模型预测值与每个模型权重重新表示，纠错之后的boosting预测值自然是更接近真实值，因此bais偏离真实值的误差会降低
		下面是将决策树与这些算法框架进行结合所得到的新的算法：
1.	Bagging + 决策树 = 随机森林
2.	AdaBoost + 决策树 = 提升树
3.	Gradient Boosting + 决策树 = GBDT
Adaboost 算法

1、	每一轮如何改变训练样本的权重？
提高哪些被前一轮弱分类器错误分类样本权重，降低正确分类的权重
2、	如何将弱分类器组成强分类器？
加权多数表决的方法：加大分类误差率小的弱分类器的权重，减小分类误差率大的弱分类器的权重。
	优缺点：
优点：泛化错误率低，易编码，可以应用在大部分分类器上，无参数可调整。
缺点：对离群数据点敏感。
适用数据类型：数值型和标称型数据。

	最基本的性质是在学习过程中不断减小训练误差。
提升树：采用加法模型与前向分布算法，以决策树为基函数数的提升方法。
前向分布算法求解经验风险极小化即损失函数极小化问题：因为学习是加法模型，从前向后每一步只学习一个基函数及其系数，逐步逼近优化目标函数。
	对于二类分类问题;提升树算法只需将Adaboost的基本分类器限制为二类树就行。
对于回归：采用平方误差损失函数，简单拟合当前模型残差即可
https://blog.csdn.net/qq_34896915/article/details/73771287
决策树模型：
决策树学习是由训练数据集估计条件概率模型。决策树学习的损失函数通常是正则化的的极大然函数。策略是以损失函数为目标函数的最小化。从所有可能的决策树中选取最优决策树是NP问题。通常采用启发式学习算法。
决策树通过自下而上进行减枝，就是去掉过于细分的叶节点，使其回退到父节点，甚至更高的节点，然后将父节点或更高的节点改为新的叶节点。
决策树包括特征选择、生成、剪纸过程。生成只考虑局部最优，剪纸则考虑全局最优。
特征选择准则是信息增益或增益比，选择信息增益最大的特征。
熵表示对随机变量不确定性的度量，熵只依赖X的分布于X取值无关。
熵越大，随机不确定性就越大。
条件熵：定义为X给定条件下Y的条件概率分布的熵对X的数学期望。
信息增益：表示得知特征X的信息而使得Y的信息的不确定性减少的程度。
决策树学习中的信息增益等价于训练数据集中类与特征的互信息。
在分类问题困难时，可以使用信息增益比，因为训练数据集的经验熵大的时候，信息增益值会偏大，反之亦然，使用信息增益比可以纠正。信息增益比等于信息增益与熵的比值。
决策的生成：
	ID3算法是各个节点用信息增益选择特征递归构建决策树。相当于使用极大似然法进行概率模型的选择。此算法只有树的生成，容易过拟合。
	C4,5与ID3一样，只是采用信息增益比。
决策树的减枝：
	通过极小化决策树整体的损失函数或代价函数来实现。（将损失函数背过）。利用损失函数最小化原则进行减枝等价于正则化的最大似然估计进行模型选择。
	如果一组叶节点回缩到其父节点之前整体树的损失函数大于回缩后的损失函数，则进行剪枝，即将父节点变更为新的叶节点。这种缺点是在局部进行。
决策树的CART（分类回归树）算法：
	在给定输入随机变量X条件下输出随机变量Y的条件概率分布的学习方法。
CART生成：
		对回归树用平方误差最小化准则和对分类树用基尼指数最小化准则，进行特征选择，生成二叉树。
	
		基尼指数表示集合D的不确定性，基尼指数越大样本集合的不确定性越大。
		选择基尼指数最小的特征及其对应的切分点作为最优特征与最优切分点。
	CART剪枝：
1、	首先从生成算法产生的决策树T0底端不断剪枝直到根节点，形成一个子树序列{T0…Tn}
2、	然后通过交叉验证法在独立的验证集上就行测试，选择最优子树。
	那么如何确定修剪多少叶子，修剪哪些叶子呢？假设由C&RT算法得到一棵完全长成树（fully-grown tree），总共10片叶子。首先分别减去其中一片叶子，剩下9片，
将这10种情况比较，取EinEin最小的那个模型；然后再从9片叶子的模型中分别减去一片，剩下8片，将这9种情况比较，取EinEin最小的那个模型。以此类推，继续修建
叶子。这样，最终得到包含不同叶子的几种模型，将这几个使用regularized decision tree的error function来进行选择，确定包含几片叶子的模型误差最小，就选
择该模型。另外，参数λ可以通过validation来确定最佳值。
